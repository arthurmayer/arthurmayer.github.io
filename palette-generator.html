<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Color Palette Generator (Simple)</title>
  <style>
    :root { --focus: #005fcc; --gap: 12px; }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; line-height: 1.5; }
    :focus-visible { outline: 3px solid var(--focus); outline-offset: 2px; }

    main { display: grid; grid-template-columns: 1fr; gap: var(--gap); padding: 16px; max-width: 1100px; margin: 0 auto; }
    @media (min-width: 920px) { main { grid-template-columns: minmax(320px, 420px) 1fr; align-items: start; } }

    .controls { display: grid; gap: var(--gap); }
    .group { display: grid; gap: 6px; }
    .inline { display: grid; grid-template-columns: auto minmax(0, 1fr); gap: 8px; align-items: center; }
    .inline > label { white-space: nowrap; }

    label { font-weight: 600; }
    input[type="number"], input[type="range"], input[type="file"], button, select { max-width: 100%; }
    input[type="number"] { width: 104px; }

    /* Keep the output visually grouped to the end of the slider */
    .range-wrap { display: inline-flex; align-items: center; gap: 6px; }
    input[type="range"] { width: 220px; }

    button { cursor: pointer; border: 1px solid #d0d0d0; border-radius: 10px; padding: 10px 14px; background: #fff; }
    button[disabled] { opacity: .6; cursor: progress; }
    button.primary { border-color: #c8d8ff; }

    .status { min-height: 1.2em; }
    .progress { height: 8px; background: #f0f0f0; border-radius: 999px; overflow: hidden; }
    .bar { height: 100%; width: 0%; background: var(--focus); transition: width .2s linear; }

    /* Dropzone + inline preview */
    .dropzone {
      border: 2px dashed #bbb;
      border-radius: 10px;
      padding: 12px;
      text-align: center;
      color: #555;
      cursor: pointer;
      display: grid;
      gap: 10px;
      justify-items: center;
    }
    .dropzone.drag { border-color: var(--focus); color: #111; }
    .dropzone.has-preview { text-align: left; }
    .dz-instructions { font-weight: 600; }
    .dz-sub { font-weight: 400; font-size: 0.95rem; color: #666; }

    .dz-preview {
      width: 100%;
      max-width: 420px;
      border-radius: 8px;
      border: 1px solid #eee;
      background: #fafafa;
      overflow: hidden;
      display: none;
      place-items: center;
      padding: 8px;
    }
    .dropzone.has-preview .dz-preview { display: grid; }
    .dz-preview canvas {
      display: block;
      max-width: 100%;
      max-height: 240px;
      width: auto;
      height: auto;
      border-radius: 8px;
      border: 1px solid #eaeaea;
      margin: 0 auto;
      background: #fff;
    }

    .results { display: grid; gap: var(--gap); }
    .palette-head { display: grid; gap: 6px; }
    .palette-controls-row { display: hidden; align-items: center; gap: 10px; flex-wrap: wrap; }

    /* Palette: desktop wraps; mobile becomes horizontal scroll */
    #palette { display: flex; flex-wrap: wrap; gap: 6px; }
    .color-swatch { width: 68px; height: 68px; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 12px; padding: 4px; text-align: center; user-select: text; cursor: pointer; }

    /* Mobile niceties (non-sticky) */
    @media (max-width: 919px) {
      button { min-height: 44px; }
      .color-swatch { width: 84px; height: 84px; font-size: 13px; }
      #palette { flex-wrap: nowrap; overflow-x: auto; padding-bottom: 6px; -webkit-overflow-scrolling: touch; }
      .dz-preview canvas { max-height: 190px; }
    }

    .visually-hidden { position: absolute !important; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }

    .hint-desktop { display: inline; }
    .hint-mobile { display: none; }
    @media (max-width: 919px) {
      .hint-desktop { display: none; }
      .hint-mobile { display: inline; }
    }
  </style>
</head>
<body>
  <main id="app" aria-labelledby="title">
    <section class="controls" aria-describedby="intro">
      <h1 id="title">Color Palette Generator</h1>
      <p id="intro">
        Upload an image, choose a palette size, then generate a palette. Click a swatch or press Enter/Space to copy its HEX.
        <span class="hint-desktop">You can also paste an image from clipboard (Ctrl/Cmd+V).</span>
        <span class="hint-mobile">(Clipboard paste may depend on device/app.)</span>
      </p>

      

      <div class="group inline">
        <label for="kInput">Palette size</label>
        <input type="number" id="kInput" value="5" min="1" max="20" inputmode="numeric" />
      </div>

      <div class="group inline">
        <label for="qualityRange">Resize quality (%)</label>
        <div class="range-wrap" aria-label="Resize quality control">
          <input type="range" id="qualityRange" min="10" max="100" value="30" step="5" aria-describedby="qualityDesc" />
          <output id="qualityVal" for="qualityRange" aria-live="polite">30</output>
        </div>
      </div>
      <p id="qualityDesc" class="visually-hidden">Lower values downscale the image before clustering to speed up processing.</p>

      <div class="group">
        <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
          <button id="runBtn" type="button" class="primary" disabled aria-disabled="true">Generate palette</button>
        </div>
        <div class="status" id="status" aria-live="polite" aria-atomic="true"></div>
        <div class="progress" aria-hidden="true"><div class="bar" id="progressBar"></div></div>
      </div>

      <div class="group">
        <input type="file" id="imgInput" accept="image/*" class="visually-hidden" />
        <label id="dropzone" class="dropzone" for="imgInput" tabindex="0" role="button"
               aria-label="Choose an image file, or drop/paste an image here">
          <div class="dz-instructions" id="dzText">
            Click to choose an image, or drop an image here, or paste from clipboard
            <div class="dz-sub">After loading, the preview will appear here. You can still click, drop, or paste to replace it.</div>
          </div>

          <div class="dz-preview" aria-label="Image preview">
            <canvas id="canvas">Uploaded image preview (canvas fallback text).</canvas>
          </div>
        </label>
      </div>

    </section>

    <section class="results" aria-labelledby="palette-title" id="results">
      <div class="palette-head">
        <h2 id="palette-title" style="margin:0;">Generated palette</h2>

        <!-- Hidden until a palette exists -->
        <div id="paletteTools" class="palette-controls-row" hidden>
          <div class="inline" style="grid-template-columns:auto auto; gap:6px; align-items:center;">
            <label for="sortSelect">Sort</label>
            <select id="sortSelect">
              <option value="lum" selected>Luminance</option>
              <option value="hue">Hue</option>
              <option value="sat">Saturation</option>
              <option value="freq">Frequency</option>
              <option value="warmcool">Warm→Cool</option>
            </select>
          </div>
          <label style="display:inline-flex; gap:6px; align-items:center; font-weight:600;">
            <input type="checkbox" id="reverseSort" />
            Reverse
          </label>
          <button id="downloadJson" type="button">Download JSON</button>
        </div>
      </div>

      <div id="palette" role="list" aria-label="Generated colors"></div>
    </section>
  </main>

  <script>
    const $ = (id) => document.getElementById(id);

    const app = $('app');
    const results = $('results');

    const imgInput = $('imgInput');
    const dropzone = $('dropzone');
    const canvas = $('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();

    const kInput = $('kInput');
    const qualityRange = $('qualityRange');
    const qualityVal = $('qualityVal');

    const paletteTools = $('paletteTools');
    const sortSelect = $('sortSelect');
    const reverseSort = $('reverseSort');
    const btnJson = $('downloadJson');

    const statusEl = $('status');
    const progressBar = $('progressBar');
    const runBtn = $('runBtn');

    const paletteDiv = $('palette');

    let lastColors = []; // [{r,g,b,count}]
    let lastCounts = []; // [count]

    // Combined button state
    let isRunning = false;
    let cancelArmedAt = 0; // debounce to avoid accidental immediate cancel

    let imageLoaded = false;

    function status(msg) { statusEl.textContent = msg; }
    function setProgress(p) { progressBar.style.width = p + '%'; }
    function setBusy(busy) {
      app.setAttribute('aria-busy', busy ? 'true' : 'false');
      results.setAttribute('aria-busy', busy ? 'true' : 'false');
    }

    function setHasPreview(has) {
      const loaded = !!has;
      imageLoaded = loaded;
      dropzone.classList.toggle('has-preview', loaded);
      dropzone.setAttribute(
        'aria-label',
        loaded
          ? 'Image loaded. Click to choose a different image, or drop/paste to replace.'
          : 'Choose an image file, or drop/paste an image here'
      );

      // Gate generation on having an image loaded
      runBtn.disabled = !loaded;
      runBtn.setAttribute('aria-disabled', (!loaded).toString());
    }

    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('').toUpperCase();
    }

    function relLum([r,g,b]){
      const s=[r,g,b].map(v=>v/255);
      const l=s.map(v=>v<=0.03928?v/12.92:Math.pow((v+0.055)/1.055,2.4));
      return 0.2126*l[0]+0.7152*l[1]+0.0722*l[2];
    }
    function contrastRatio(a,b){
      const L1=relLum(a),L2=relLum(b);
      return (Math.max(L1,L2)+.05)/(Math.min(L1,L2)+.05);
    }

    // HSL helpers for sorting
    function toHSL({r,g,b}){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      let h=0, s=0, l=(max+min)/2;
      if(max!==min){
        const d=max-min;
        s = l>0.5 ? d/(2-max-min) : d/(max+min);
        switch(max){
          case r: h=(g-b)/d + (g<b?6:0); break;
          case g: h=(b-r)/d + 2; break;
          default: h=(r-g)/d + 4; break;
        }
        h *= 60;
      }
      return { h, s: s*100, l: l*100 };
    }

    function warmCoolScore({r,g,b}){
      const {h} = toHSL({r,g,b});
      const distToWarm = Math.min(Math.abs(h-30), Math.abs(h-360-30), Math.abs(h-0));
      const distToCool = Math.abs(h-220);
      return distToWarm - distToCool; // negative = warmer
    }

    qualityRange.addEventListener('input', () => { qualityVal.value = qualityRange.value; });

    // --- Image loading (file + clipboard + drop) ---
    function loadFile(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        img.onload = () => {
          // Keep intrinsic canvas size as the real image. Preview scaling is CSS-only.
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          setHasPreview(true);
          status('Image loaded. Ready to generate palette.');
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    }

    imgInput.addEventListener('change', (e) => loadFile(e.target.files && e.target.files[0]));

    // Paste from clipboard
    document.addEventListener('paste', (e) => {
      const items = e.clipboardData && e.clipboardData.items;
      if (!items) return;
      for (const item of items) {
        if (item.type && item.type.startsWith('image/')) {
          const file = item.getAsFile();
          loadFile(file);
          return;
        }
      }
    });

    // Drag & drop on dropzone label (still works after preview)
    ['dragenter', 'dragover'].forEach(type => dropzone.addEventListener(type, (e) => {
      e.preventDefault();
      dropzone.classList.add('drag');
    }));
    ['dragleave', 'drop'].forEach(type => dropzone.addEventListener(type, (e) => {
      e.preventDefault();
      dropzone.classList.remove('drag');
      if (type === 'drop') {
        const file = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
        loadFile(file);
      }
    }));

    // Make Enter/Space on dropzone open file picker
    dropzone.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        imgInput.click();
      }
    });

    // --- JSON download ---
    function download(name, blob) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = name;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
    }

    function exportJSON() {
      const data = {
        name: 'Palette',
        sort: sortSelect.value,
        reverse: reverseSort.checked,
        colors: lastColors.map(c => ({ hex: rgbToHex(c.r, c.g, c.b), r: c.r, g: c.g, b: c.b, count: c.count }))
      };
      download('palette.json', new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' }));
    }

    btnJson.addEventListener('click', exportJSON);

    // --- K-means in Web Worker (always K-means++ init) ---
    let worker = null;
    let workerURL = null;

    function buildWorker() {
      if (workerURL) URL.revokeObjectURL(workerURL);

      const code = `
self.onmessage = function(e) {
  const { pixels, k, maxIter } = e.data;
  const n = pixels.length / 4;

  const samples = new Array(n);
  for (let i = 0, j = 0; i < n; i++, j += 4) samples[i] = [pixels[j], pixels[j+1], pixels[j+2]];

  function dist2(a,b){ const dr=a[0]-b[0], dg=a[1]-b[1], db=a[2]-b[2]; return dr*dr + dg*dg + db*db; }

  function kmeansPlusPlus(){
    const centers = [];
    centers.push(samples[Math.floor(Math.random()*n)].slice());
    while (centers.length < k) {
      const dists = samples.map(s => centers.reduce((m,c)=>Math.min(m, dist2(s,c)), Infinity));
      let sum = 0; for (const d of dists) sum += d;
      let r = Math.random() * sum;
      let idx = 0;
      for (; idx < dists.length; idx++) { r -= dists[idx]; if (r <= 0) break; }
      centers.push(samples[Math.min(idx, samples.length-1)].slice());
    }
    return centers;
  }

  let centers = kmeansPlusPlus();
  let labels = new Array(n).fill(0);
  let changed = true;
  let iter = 0;

  while (changed && iter < maxIter) {
    changed = false;
    iter++;

    for (let i = 0; i < n; i++) {
      let best = 0, bestD = Infinity;
      const s = samples[i];
      for (let c = 0; c < k; c++) {
        const d = dist2(s, centers[c]);
        if (d < bestD) { bestD = d; best = c; }
      }
      if (labels[i] !== best) { labels[i] = best; changed = true; }
    }

    const sums = Array.from({length:k}, ()=>[0,0,0,0]);
    for (let i = 0; i < n; i++) {
      const l = labels[i];
      const s = samples[i];
      sums[l][0] += s[0];
      sums[l][1] += s[1];
      sums[l][2] += s[2];
      sums[l][3] += 1;
    }
    for (let c = 0; c < k; c++) {
      if (sums[c][3] > 0) {
        centers[c] = [
          Math.round(sums[c][0]/sums[c][3]),
          Math.round(sums[c][1]/sums[c][3]),
          Math.round(sums[c][2]/sums[c][3])
        ];
      }
    }

    if (iter % 2 === 0) self.postMessage({ type: 'progress', value: Math.min(95, Math.round((iter/maxIter)*100)) });
  }

  const counts = new Array(k).fill(0);
  for (let i = 0; i < n; i++) counts[labels[i]]++;

  self.postMessage({ type: 'done', centers, counts, iterations: iter });
};
`;

      workerURL = URL.createObjectURL(new Blob([code], { type: 'application/javascript' }));
      worker = new Worker(workerURL);

      worker.onmessage = (e) => {
        const msg = e.data;
        if (msg.type === 'progress') {
          setProgress(msg.value);
        } else if (msg.type === 'done') {
          renderPalette(msg.centers, msg.counts);
          setProgress(100);
          status(`Palette generated in ${msg.iterations} iterations.`);
          stopRunningState();
        }
      };
    }

    function destroyWorker() {
      if (worker) worker.terminate();
      worker = null;
      if (workerURL) URL.revokeObjectURL(workerURL);
      workerURL = null;
    }

    function startRunningState() {
      isRunning = true;
      cancelArmedAt = performance.now() + 100;
      runBtn.textContent = 'Cancel generation';
      runBtn.setAttribute('aria-label', 'Cancel generation');
      setBusy(true);
      status('Generating palette… Button changed to Cancel.');
    }

    function stopRunningState() {
      isRunning = false;
      runBtn.textContent = 'Generate palette';
      runBtn.setAttribute('aria-label', 'Generate palette');
      setBusy(false);
      setProgress(0);
    }

    function generatePalette() {
      if (!canvas.width || !canvas.height) {
        status('Please upload or paste an image first.');
        return;
      }

      if (!worker) buildWorker();

      const q = parseInt(qualityRange.value, 10) / 100;
      const tw = Math.max(1, Math.round(canvas.width * q));
      const th = Math.max(1, Math.round(canvas.height * q));

      const tmp = document.createElement('canvas');
      tmp.width = tw;
      tmp.height = th;
      const tctx = tmp.getContext('2d', { willReadFrequently: true });
      tctx.drawImage(canvas, 0, 0, tw, th);
      const imgData = tctx.getImageData(0, 0, tw, th);

      const k = parseInt(kInput.value, 10);
      setProgress(10);
      startRunningState();
      worker.postMessage({ pixels: imgData.data, k, maxIter: 12 });
    }

    function cancelGeneration() {
      if (!worker) return;
      if (performance.now() < cancelArmedAt) return;

      destroyWorker();
      status('Generation canceled.');
      stopRunningState();
    }

    runBtn.addEventListener('click', () => {
      if (isRunning) cancelGeneration();
      else generatePalette();
    });

    // Sorting
    function sortColors(colors, counts) {
      const mode = sortSelect.value;
      const rev = reverseSort.checked;
      const withCounts = colors.map((c, i) => ({...c, count: counts?.[i] ?? 0 }));
      const dir = rev ? -1 : 1;

      if (mode === 'lum') {
        withCounts.sort((a,b) => dir * (relLum([a.r,a.g,a.b]) - relLum([b.r,b.g,b.b])));
      } else if (mode === 'hue') {
        withCounts.sort((a,b) => dir * (toHSL(a).h - toHSL(b).h));
      } else if (mode === 'sat') {
        withCounts.sort((a,b) => dir * (toHSL(a).s - toHSL(b).s));
      } else if (mode === 'freq') {
        withCounts.sort((a,b) => dir * ((b.count||0) - (a.count||0)));
      } else if (mode === 'warmcool') {
        withCounts.sort((a,b) => dir * (warmCoolScore(a) - warmCoolScore(b)));
      }

      return withCounts;
    }

    function renderPalette(centers, counts) {
      const colors = centers.map(([r,g,b]) => ({ r, g, b }));
      const sorted = sortColors(colors, counts);
      lastColors = sorted.map(c => ({ r:c.r, g:c.g, b:c.b, count:c.count }));
      lastCounts = sorted.map(c => c.count);

      // only show tools once palette exists
      paletteTools.style['display'] = 'flex';
      paletteTools.hidden = false;
      paintPalette();
    }

    function paintPalette(){
      paletteDiv.innerHTML = '';
      lastColors.forEach((c, i) => {
        const hex = rgbToHex(c.r, c.g, c.b);
        const sw = document.createElement('div');
        sw.className = 'color-swatch';
        sw.setAttribute('role', 'listitem');
        sw.tabIndex = 0;
        sw.setAttribute('data-hex', hex);
        sw.setAttribute('aria-label', `Color ${i+1}: ${hex}. Activate to copy.`);
        sw.title = 'Click or press Enter/Space to copy';
        sw.style.background = hex;

        const cb = contrastRatio([c.r,c.g,c.b],[0,0,0]);
        const cw = contrastRatio([c.r,c.g,c.b],[255,255,255]);
        sw.style.color = (cw >= cb) ? '#fff' : '#000';

        sw.textContent = hex;
        paletteDiv.appendChild(sw);
      });
    }

    function resortExisting(){
      if (!lastColors.length) return;
      const colors = lastColors.map(({r,g,b})=>({r,g,b}));
      const sorted = sortColors(colors, lastCounts);
      lastColors = sorted.map(c => ({ r:c.r, g:c.g, b:c.b, count:c.count }));
      lastCounts = sorted.map(c => c.count);
      paintPalette();
    }

    sortSelect.addEventListener('change', resortExisting);
    reverseSort.addEventListener('change', resortExisting);

    async function copyText(text) {
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
        } else {
          const ta = document.createElement('textarea');
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          ta.remove();
        }
        status(`Copied ${text} to clipboard.`);
      } catch {
        status(`Could not copy ${text}.`);
      }
    }

    paletteDiv.addEventListener('click', (e) => {
      const sw = e.target.closest('.color-swatch');
      if (!sw) return;
      copyText(sw.getAttribute('data-hex'));
    });

    paletteDiv.addEventListener('keydown', (e) => {
      const sw = e.target.closest('.color-swatch');
      if (!sw) return;
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        copyText(sw.getAttribute('data-hex'));
      }
    });

    // Keyboard shortcuts: G generate, Esc cancel (only when running)
    document.addEventListener('keydown', (e) => {
      if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT')) return;
      if (e.key.toLowerCase() === 'g' && !isRunning && imageLoaded) generatePalette();
      if (e.key === 'Escape' && isRunning) cancelGeneration();
    });

    status('Ready. Upload, drop, or paste an image to begin.');
    setHasPreview(false);
  </script>
</body>
</html>
